## Миграционная совместимость
Чтобы устранить все возможные недоразумения по поводу стирания, необходимо четко понимать, что оно не является особенностью языка. Это компромисс в реализации обобщений^уа, неизбежный из-за того, что обобщения не были частью языка с самого начала. Этот компромисс принесет вам немало неприятностей, поэтому постарайтесь пораньше привыкнуть к нему и понять, почему он появился

В реализации со стиранием обобщенные типы рассматриваются как «второсортные» типы, которые не могут использоваться в некоторых важных контекстах. Обобщенные
типы присутствуют только во время статической проверки типов, после которой каждый обобщенный тип в программе стирается, то есть заменяется необобщенным верхним ограничением.
Например, обозначение вида List<T> стирается до List, а переменные обычных типов стираются до Object (если не задано ограничение).

Допустим, приложение использует две библиотеки, X и Y, и Y использует библиотеку Z. С выходом Java SE5 создатели этого приложения и библиотек с большой вероятностью захотят перевести свой код на обобщения, но все они будут руководствоваться собственными соображениями и ограничениями в отношении того, когда эта миграция произойдет. Для достижения миграционной совместимости каждая библиотека и приложение не должны зависеть от других в отношении использования обобщений. А следовательно, они не должны иметь возможность обнаружить, использует ли другой код обобщения или нет. Таким образом, все признаки использования обобщений конкретной библиотекой должны быть «стерты».

## Проблема стирания
Итак, главной причиной для реализации стирания является процесс перехода от необобщенного кода к обобщенному и возможность встраивания обобщений в язык без нарушения работоспособности существующих библиотек. Благодаря стиранию существующий необобщенный клиентский код используется без изменений, пока клиенты не будут готовы переписать код для поддержки обобщений. Это стоящая цель, потому что она предотвращает внезапное нарушение работоспособности всего существующего кода.

За стирание приходится заплатить значительную цену. Обобщенные типы не могут использоваться в операциях, в которых явно задействуются типы времени выполнения — приведения типов, операции instanceof и выражения new. Так как вся информация о типе параметров теряется, при написании обобщенного кода вы должны постоянно напоминать себе, что наличие информации о типе — не более чем видимость. Таким образом, когда вы пишете фрагмент кода вида:

код класса Foo должен знать, что теперь он работает с Cat. Синтаксис создает впечатление, что тип т автоматически подставляется везде, где он используется в классе. Но это не так, и при написании кода класса вы должны постоянно напоминать себе: «Нет, это всего лишь Object».

Кроме того, стирание и миграционная совместимость означают, что правильность использования обобщений не обеспечивается там, где это было бы желательно:
Добавьте к этому дополнительный труд по управлению ограничениями, когда вы хотите интерпретировать параметр-тип как нечто большее, чем просто Object, — и в результате вы получаете существенно больше усилий при меньшей пользе, чем при использовании параметризованныхтипов в таких языках, как С++, Ada или Eiffel. Это означает не то, что эти языки в целом работают эффективнее^уа для большинства задач программирования, а лишь то, что поддержка параметризованных типов в этих языках обладает большей гибкостью и мощью, чем eJava.

## Граничные ситуации
При том, что kind хранится в виде Class<T>, механизм стирания означает, что в действительности хранится только Class без параметра. Таким образом, при выполнении любой операции (например, создании массива) Array.newlnstance() не располагает информацией типа, подразумеваемой для kind; следовательно, метод не может выдать конкретный результат, и возникает необходимость в приведении типа с выдачей предупреждения.
Метод Array.newlnstance() рекомендуется использовать для создания массивов в обобщениях.

Хотя компилятор не может ничего знать о T внутри create(), он все равно может проследить (во время компиляции) за тем, что значения, помещаемые в result, относятся к типу Т, и поэтому соглашается с ArrayList<T>. Итак, хотя стирание удаляет информацию о фактическом типе внутри метода или класса, компилятор все равно может обеспечить внутреннюю целостность использования типа в методе или классе.

Так как методы get() и set() генерируют одинаковый байт-код, все действие происходит в граничных точках — дополнительная проверка входных значений во время компиляции и вставляемое приведение типа для выходных значений. Для прояснения путаницы со стиранием полезно запомнить, что «все реальные действия происходят в граничных точках».

## Компенсация стирания


549
## Маски
Первая строка main() создает массив Apple и присваивает его ссылке на массив Fruit. Это разумно — яблоко (Apple) является разновидностью фрукта (Fruit), так что массив элементов Apple также может рассматриваться как массив Fruit.
Но если фактическим типом массива является Арр1е[],то в массив могут помещаться только объекты типа Apple или типов, производных от Apple, что фактически работает как во время компиляции, так и во время выполнения. Но обратите внимание: компилятор позволяет поместить объект Fruit в массив. Для компилятора это выглядит
логично, потому что он работает со ссылкой Fruit [ ], — так почему бы не разрешить включение в массив объекта Fruit или типа, производного от Fruit (например, Ocange)? Во время компиляции это допустимо. Однако ядро времени выполнения знает, что оно имеет дело с Apple[], и выдает исключение при помещении в массив постороннего типа.,

Пожалуй, термин «восходящее преобразование» здесь не совсем точен — в действительности происходит присваивание одного массива другому. Хотя массив содержит другие объекты, из-за возможности восходящего преобразования очевидно, что объект массива может обеспечить выполнение требований к типу содержащихся в нем объектов. Массив «знает», что в нем хранится, так что между проверками времени компиляции и проверками времени выполнения никакие злоупотребления невозможны.
Для массивов такая ситуация не столь ужасна, потому что вы сможете узнать во время выполнения о вставке неподходящего типа. Но одной из основных целей обобщений является обнаружение подобных ошибок во время компиляции.

И хотя на первый взгляд это читается как «Контейнер с элементами Apple нельзя присвоить контейнеру Fruit», помните, что применение
обобщений не сводится к контейнерам. По сути говорится другое: «Обобщение с Apple не может быть присвоено обобщению с Fruit».
на деле это не является «восходящим преобразованием» — контейнер List с элементами Apple не является List с элементами Fruit.
В контейнере List с элементами Apple могут храниться объекты типа Apple и типов, производных от Apple, а в контейнере List с
элементами Fruit могут храниться любые разновидности Fruit. Да, в том числе и Apple, но от этого контейнер не становится контейнером
List с элементами Apple; он остается контейнером List с элементами Fruit. Контейнер List с элементами Apple не эквивалентен по типу контейнеру
List с элементами Fruit, несмотря на то что Apple является разновидностью Fruit.
Настоящая проблема заключается в том, что речь идет о типе контейнера, а не о типе элементов, хранящихся в контейнере.
В отличие от массивов обобщения не обладают встроенной ковариантностью. Это связано с тем, что массивы полностью определяются в языке,
а следовательно, для них реализованы встроенные проверки как на стадии компиляции, так и на стадии выполнения,

Однако в некоторых ситуациях между двумя типами желательно установить некую разновидность отношений восходящего преобразования.

Для этой цели и используются маски (wildcards).

Теперь flist имеет тип List<? extends Fruit>, что можно прочитать как «список с элементами любого типа, производного от Fruit». Однако это не означает, что в List можно будет хранить любые виды Fruit. Маска относится к определенному типу, так что это означает «некоторый конкретный тип, не указанный для ссылки flist». Итак, присваиваемый объект List должен содержать некоторый указанный тип (например, Fruit или Apple), но для восходящего преобразования к flist этот тип несущественен.

## Насколько умен компилятор?
552


## Контравариантность

## Неограниченные маски 556

Неограниченная маска <?> означает «что угодно», так что может показаться, что использование неограниченной маски эквивалентно
использованию самого типа. Действительно, компилятор на первый взгляд соглашается с этим предположением

Во многих ситуациях компилятор действительно совершенно не интересует, используете ли вы сам тип или <?>.
В таких случаях <?> можно рассматривать как обычное украшение. Тем не менее маска все же полезна, потому что она
фактически говорит: «Этот код написан с учетом обобщений^уа, и здесь имеется в виду, что в обобщенном параметре
может передаваться любой тип».

Если обобщение состоит только из неограниченных масок, как **Мар<?, ?>**, компилятор, похоже, не отличает его от «обычного» типа Мар.
Кроме того, **UnboundedWildcardsl.java** показывает, что компилятор по-разному рассматривает List<?> и List<? extends Object>.
При этом компилятор не всегда обращает внимание на различия между, допустим, **List** и **List<?>**; создается впечатление, что это
одно и то же, а это может породить путаницу. В самом деле, поскольку обобщенный аргумент стирается до первого ограничения,
List<?> кажется эквивалентом List<object>, а List по сути тоже является List<Object> — впрочем, оба эти утверждения не совсем точны.
List в действительности означает «неспециализированный контейнер List, в котором могут храниться любые объекты Object»,
тогда как List<?> означает «специализация List для конкретного типа, который нам неизвестен».

В rawArgs() компилятор знает, что Holder является обобщенным типом, поэтому даже несмотря на то, что здесь он
выражается неспециализированным типом, компилятор знает, что передача Object методу set() небезопасна.
Так как это неспециализированный тип, методу set() можно передать объект любого типа, и этот объект будет приведен к
Object восходящим преобразованием. Итак, каждый раз, когда вы используете неспециализированный тип, вы отказываетесь
от проверки на стадии компиляции. Вызов get() демонстрирует ту же проблему: при отсутствии т результатом может быть только Object.

Легко прийти к мнению, что неспециализированные типы Holder и Holder<?> обозначают приблизительно одно и то же.
Но метод unboundedArg() подчеркивает различия между ними — он выявляет те же проблемы, но сообщает о них как об
ошибках, а не как о предупреждениях, потому что неспециализированный тип Holder может содержать комбинацию любых типов,
а Holder<?> содержит однородную коллекцию некоторого конкретного типа, а следовательно, передать Object просто не получится.
В exact1() и exact2() используются точные параметры обобщений — без масок. Как видно по дополнительному аргументу, exact2()
имеет другие ограничения, чем exact1(). В wildSubtype() ограничения для типа Holder ослабляются до Holder для любых
типов, расширяющих T. И снова это означает, что типом т может быть Fruit, тогда как holder может содержать Holder<Apple>.
Чтобы предотвратить помещение Orange в Holder<Apple>, вызов set () (или любого другого метода, получающего параметр-тип) запрещен.
Но при этом вы знаете, что все, что выходит из Holder< ? extends Fruit>, будет по меньшей мере Fruit, поэтому вызов get()
(или любого метода, возвращающего параметр-тип) разрешен.

Легко прийти к мнению, что неспециализированные типы Holder и Holder<?> обозначают приблизительно одно и то же. Но метод unboundedArg()
подчеркивает различия между ними — он выявляет те же проблемы, но сообщает о них как об ошибках, а не как о предупреждениях, потому что
неспециализированный тип Holder может содержать комбинацию любых типов, а Holder<?> содержит однородную коллекцию некоторого конкретного
типа, а следовательно, передать Object просто не получится.

В wildSubtype() ограничения для типа Holder ослабляются до Holder для любых типов, расширяющих T. И снова это означает,
что типом т может быть Fruit, тогда как holder может содержать Holder<Apple>. Чтобы предотвратить помещение Orange в Holder<Apple>,
вызов set () (или любого другого метода, получающего параметр-тип) запрещен. Но при этом вы знаете, что все, что выходит
из Holder< ? extends Fruit>, будет по меньшей мере Fruit, поэтому вызов get() (или любого метода, возвращающего параметр-тип) разрешен.

Применение маски супертипа продемонстрировано в методе **wildSupertype()**, поведение которого обратно поведению wildSubtype():
holder может содержать контейнер с элементами любого типа, который является разновидностью базового класса т. Таким образом,
**setValue ()** может принять **T**, так как все, что работает с базовым типом, будет полиморфно работать с производным типом (отсюда т).
Однако попытка вызова **getValue()** пользы не принесет, потому что тип, хранимый в **holder**, может быть абсолютно любым супертипом,
поэтому единственным безопасным вариантом является **Object**. Этот пример также показывает ограниченные возможности выполнения
операций с неограниченным параметром в **unbounded()**: вы не можете вызвать **getValue()** или **set()** для **T**, потому что у вас нет **T**.

В методе **main()** мы видим, какие из этих методов могут получать те или иные типы аргументов без ошибок и предупреждений.
Для обеспечения миграционной совместимости **rawArgs()** будет получать все разновидности **Holder** без выдачи предупреждений.
Метод **unboundedArg()** также принимает все типы, хотя, как упоминалось ранее, в теле метода он работает с ними иначе.

Если передать неспециализированную ссылку **Holder** методу, который получает «точный» обобщенный тип (без маски),
вы получите предупреждение, потому что точный аргумент ожидает получить информацию, не существующую в неспециализированном типе.
И если передать неограниченную ссылку **exact1()**, то у компилятора не будет информации о типе для установления возвращаемого типа.
Мы видим, что метод **exact2()** имеет больше всего ограничений, поскольку он должен получать **Holder<T>** и аргумент типа **T**;
не получив точных аргументов, он выдает ошибки и предупреждения. Иногда такой подход приемлем, но если он создает неудобства,
вы можете использовать маски в зависимости от того, хотите ли вы получать возвращаемые значения из своего обобщенного аргумента
(как в **wildSubtype()**) или передавать в нем типизованные аргументы (как в **wildSupertype()**).

Таким образом, преимущество использования точных типов вместо масок заключается в том, что оно позволяет больше сделать
с обобщенными параметрами.

С другой стороны, использование масок позволяет принять в аргументах более широкий диапазон параметризованных типов.
Вы должны решить, какой из вариантов лучше подходит для ваших потребностей, в каждом конкретном случае.

## Фиксация

Есть ситуация, в которой использование <?> вместо неспециализированного типа особенно принципиально.
Если передать неспециализированный тип методу, использующему<?>, компилятор может автоматически вычислить фактический
параметр-тип и вызвать другой метод, использующий точный тип. Следующий пример демонстрирует работу этого механизма,
который называется фиксацией (capture conversion), потому что неуказанный тип маски фиксируется и преобразуется к точному типу.
В этом случае комментарии о предупреждениях действуют только при удалении аннотации **@SuppressWarnings**:

Все параметры-типы f1() являются точными, не содержат масок или ограничений. В f2() параметр Holder является неограниченной маской,
так что на первый взгляд он фактически неизвестен. Однако в f2 () вызывается метод f1 (), которому требуется известный параметр.
Здесь параметр-тип фиксируется в процессе вызова f2() и может использоваться при вызове f1().

Нельзя ли использовать эту методику для записи? Для этого вместе с Holder<?> необходимо передавать конкретный тип.
Фиксация работает только в ситуациях, при которых внутри метода необходимо работать с точным типом. Учтите, что вы не можете вернуть
т из f2(), потому что тип т неизвестен для f2(). Фиксация — интересный механизм, но его возможности невелики.

## Проблемы

### Примитивы не могут использоваться как параметры-типы

Как упоминалось ранее в этой главе, один из недостатков o6o6ntemmJava заключается в том, что примитивы не могут использоваться 
в качестве параметров-типов. Таким образом, например, вы не сможете создать ArrayList<int>.

Проблема решается использованием примитивных классов-«оберток» в сочетании с автоматической ynaKOBKoftJava SE. 
Если вы создадите ArrayList<lnteger> и используете примитивные значения int с этим контейнером, вы обнаружите, 
что автоматическая упаковка выполняет преобразование к Integer и обратно автоматически — все выглядит так, словно 
вы работаете с ArrayList<int>:

Автоматическая упаковка даже позволяет использовать синтаксис foreach для производства int. В общем случае такое решение работает 
нормально — ваш код может успешно сохранять и читать int. При этом выполняются некоторые преобразования типа, но они остаются 
скрытыми от вас. Впрочем, если лишние преобразования создают проблемы с производительностью, вы можете использовать 
специализированную версию контейнеров, приспособленную для примитивных типов; одна из реализаций, с открытым кодом доступна 
по адресу org.apache.commons.collections.primitives.

Класс FArray содержит обобщенный метод, использующий генератор для заполнения массива объектами (переход к обобщенному классу 
в данном случае не работает, потому что метод является статическим). Реализации Generator взяты из главы 16, а в методе main() 
продемонстрировано использование FArray.fill() для заполнения массива объектами:

30. (2) Создайте объект Holder для каждой «обертки» примитивного типа.
    Продемонстрируйте, что автоматическая упаковка и распаковка работает для методов set () и get() каждого экземпляра

Так как RandomGenerator.lnteger реализует Generator<Integer>, я надеялся, что автоматическая упаковка преобразует значение next() 
из Integer в int. Однако автоматическая упаковка не применяется к массивам, поэтому решение не работает.

## Реализация параметризованных интерфейсов

Класс Hourly не компилируется, потому что стирание сокращает Payable<Employee> и Payable<Hourly> до одного класса 
Payable, а приведенный выше код будет означать, что один интерфейс реализуется дважды. Интересно, что при удалении 
обобщенных параметров из обоих мест использования РауаЫе (как это делает компилятор при стирании) код откомпилируется.
Эта проблема проявляется при работе с некоторыми фундаментальными интерфейсами Java (такими, как Comparable<T>), как будет 
показано позже в этом разделе.

## Приведения типа и предупреждения
Без аннотации @SuppressWarnings компилятор выдает для pop() предупреждение «неконтролируемое приведение типа». 
Из-за стирания он не знает, безопасно ли приведение типа, и метод pop() не выполняет никакого реального приведения, 
T стирается по первому ограничению, которым по умолчанию является Object, так что pop() фактически просто преобразует Object в Object.

