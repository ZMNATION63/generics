## Миграционная совместимость

Чтобы устранить все возможные недоразумения по поводу стирания, необходимо четко понимать, что оно не является особенностью языка. 
Это компромисс в реализации обобщений, а неизбежный из-за того, что обобщения не были частью языка с самого начала. Этот компромисс 
принесет вам немало неприятностей, поэтому постарайтесь пораньше привыкнуть к нему и понять, почему он появился

В реализации со стиранием обобщенные типы рассматриваются как «второсортные» типы, которые не могут использоваться в некоторых важных контекстах. 
Обобщенные типы присутствуют только во время статической проверки типов, после которой каждый обобщенный тип в программе стирается, 
то есть заменяется необобщенным верхним ограничением.
Например, обозначение вида `List<T>` стирается до `List`, а переменные обычных типов стираются до `Object` (если не задано ограничение).

Допустим, приложение использует две библиотеки, `X` и `Y`, и `Y` использует библиотеку `Z`. С выходом `Java SE5` создатели этого приложения и 
библиотек с большой вероятностью захотят перевести свой код на обобщения, но все они будут руководствоваться собственными соображениями и 
ограничениями в отношении того, когда эта миграция произойдет. Для достижения миграционной совместимости каждая библиотека и приложение не 
должны зависеть от других в отношении использования обобщений. А следовательно, они не должны иметь возможность обнаружить, использует ли
другой код обобщения или нет. Таким образом, все признаки использования обобщений конкретной библиотекой должны быть «стерты».

## Проблема стирания

Итак, главной причиной для реализации стирания является процесс перехода от необобщенного кода к обобщенному и возможность встраивания 
обобщений в язык без нарушения работоспособности существующих библиотек. Благодаря стиранию существующий необобщенный клиентский код 
используется без изменений, пока клиенты не будут готовы переписать код для поддержки обобщений. Это стоящая цель, потому что она 
предотвращает внезапное нарушение работоспособности всего существующего кода.

За стирание приходится заплатить значительную цену. Обобщенные типы не могут использоваться в операциях, в которых явно задействуются 
типы времени выполнения — приведения типов, операции `instanceof` и выражения new. Так как вся информация о типе параметров теряется, 
при написании обобщенного кода вы должны постоянно напоминать себе, что наличие информации о типе — не более чем видимость. Таким образом, 
когда вы пишете фрагмент кода вида:

код класса Foo должен знать, что теперь он работает с `Cat`. Синтаксис создает впечатление, что тип т автоматически подставляется везде, 
где он используется в классе. Но это не так, и при написании кода класса вы должны постоянно напоминать себе: «Нет, это всего лишь `Object`».

Кроме того, стирание и миграционная совместимость означают, что правильность использования обобщений не обеспечивается там, где это было бы желательно:
Добавьте к этому дополнительный труд по управлению ограничениями, когда вы хотите интерпретировать параметр-тип как нечто большее, чем просто 
`Object`, — и в результате вы получаете существенно больше усилий при меньшей пользе, чем при использовании параметризованныхтипов в 
таких языках, как `С++`, `Ada` или `Eiffel`. Это означает не то, что эти языки в целом работают эффективнее, а для большинства задач 
программирования, а лишь то, что поддержка параметризованных типов в этих языках обладает большей гибкостью и мощью, чем `eJava`.

## Граничные ситуации
При том, что `kind` хранится в виде `Class<T>`, механизм стирания означает, что в действительности хранится только `Class` без параметра. 
Таким образом, при выполнении любой операции (например, создании массива) Array.newlnstance() не располагает информацией типа, 
подразумеваемой для kind; следовательно, метод не может выдать конкретный результат, и возникает необходимость в приведении типа с выдачей предупреждения.
Метод `Array.newlnstance()` рекомендуется использовать для создания массивов в обобщениях.

Хотя компилятор не может ничего знать о `T` внутри `create()`, он все равно может проследить (во время компиляции) за тем, что значения,
помещаемые в `result`, относятся к типу `Т`, и поэтому соглашается с `ArrayList<T>`. Итак, хотя стирание удаляет информацию о фактическом 
типе внутри метода или класса, компилятор все равно может обеспечить внутреннюю целостность использования типа в методе или классе.

Так как методы `get()` и `set()` генерируют одинаковый байт-код, все действие происходит в граничных точках — дополнительная проверка входных
значений во время компиляции и вставляемое приведение типа для выходных значений. Для прояснения путаницы со стиранием полезно запомнить, 
что «все реальные действия происходят в граничных точках».

## Компенсация стирания

549
## Маски
Первая строка `main()` создает массив `Apple` и присваивает его ссылке на массив `Fruit`. Это разумно — яблоко `(Apple)` является разновидностью
фрукта (Fruit), так что массив элементов `Apple` также может рассматриваться как массив `Fruit`.
Но если фактическим типом массива является Аррlе[],то в массив могут помещаться только объекты типа Apple или типов, производных от `Apple`, 
что фактически работает как во время компиляции, так и во время выполнения. Но обратите внимание: компилятор позволяет поместить объект 
`Fruit` в массив. Для компилятора это выглядит логично, потому что он работает со ссылкой `Fruit[]`, — так почему бы не разрешить 
включение в массив объекта `Fruit` или типа, производного от `Fruit` (например, `Ocange`)? Во время компиляции это допустимо. Однако ядро 
времени выполнения знает, что оно имеет дело с `Apple[]`, и выдает исключение при помещении в массив постороннего типа.

Пожалуй, термин «восходящее преобразование» здесь не совсем точен — в действительности происходит присваивание одного массива другому. 
Хотя массив содержит другие объекты, из-за возможности восходящего преобразования очевидно, что объект массива может обеспечить выполнение 
требований к типу содержащихся в нем объектов. Массив «знает», что в нем хранится, так что между проверками времени компиляции и проверками 
времени выполнения никакие злоупотребления невозможны.
Для массивов такая ситуация не столь ужасна, потому что вы сможете узнать во время выполнения о вставке неподходящего типа. Но одной 
из основных целей обобщений является обнаружение подобных ошибок во время компиляции.

И хотя на первый взгляд это читается как «Контейнер с элементами `Apple` нельзя присвоить контейнеру `Fruit`», помните, что применение
обобщений не сводится к контейнерам. По сути говорится другое: «Обобщение с Apple не может быть присвоено обобщению с `Fruit`».
на деле это не является «восходящим преобразованием» — контейнер `List` с элементами Apple не является `List` с элементами `Fruit`.
В контейнере `List` с элементами `Apple` могут храниться объекты типа `Apple` и типов, производных от `Apple`, а в контейнере `List` с
элементами `Fruit` могут храниться любые разновидности `Fruit`. Да, в том числе и `Apple`, но от этого контейнер не становится контейнером
`List` с элементами `Apple`; он остается контейнером `List` с элементами `Fruit`. Контейнер `List` с элементами `Apple` не эквивалентен по типу контейнеру
`List` с элементами `Fruit`, несмотря на то что `Apple` является разновидностью `Fruit`.
Настоящая проблема заключается в том, что речь идет о типе контейнера, а не о типе элементов, хранящихся в контейнере.
В отличие от массивов обобщения не обладают встроенной ковариантностью. Это связано с тем, что массивы полностью определяются в языке,
а следовательно, для них реализованы встроенные проверки как на стадии компиляции, так и на стадии выполнения,

Однако в некоторых ситуациях между двумя типами желательно установить некую разновидность отношений восходящего преобразования.

Для этой цели и используются маски (`wildcards`).

Теперь `flist` имеет тип `List<? extends Fruit>`, что можно прочитать как «список с элементами любого типа, производного от `Fruit`». 
Однако это не означает, что в List можно будет хранить любые виды `Fruit`. Маска относится к определенному типу, так что это означает 
«некоторый конкретный тип, не указанный для ссылки `flist`». Итак, присваиваемый объект List должен содержать некоторый указанный тип 
(например, `Fruit` или `Apple`), но для восходящего преобразования к `flist` этот тип несущественен.

## Насколько умен компилятор?
552


## Контравариантность

## Неограниченные маски 556

Неограниченная маска <?> означает «что угодно», так что может показаться, что использование неограниченной маски эквивалентно
использованию самого типа. Действительно, компилятор на первый взгляд соглашается с этим предположением

Во многих ситуациях компилятор действительно совершенно не интересует, используете ли вы сам тип или <?>.
В таких случаях <?> можно рассматривать как обычное украшение. Тем не менее маска все же полезна, потому что она
фактически говорит: «Этот код написан с учетом обобщений^уа, и здесь имеется в виду, что в обобщенном параметре
может передаваться любой тип».

Если обобщение состоит только из неограниченных масок, как `Мар<?, ?>`, компилятор, похоже, не отличает его от «обычного» типа Мар.
Кроме того, `UnboundedWildcardsl.java` показывает, что компилятор по-разному рассматривает `List<?>` и `List<? extends Object>`.
При этом компилятор не всегда обращает внимание на различия между, допустим, **List** и **List<?>**; создается впечатление, что это
одно и то же, а это может породить путаницу. В самом деле, поскольку обобщенный аргумент стирается до первого ограничения,
List<?> кажется эквивалентом `List<object>`, а List по сути тоже является `List<Object>` — впрочем, оба эти утверждения не совсем точны.
List в действительности означает «неспециализированный контейнер List, в котором могут храниться любые объекты Object»,
тогда как List<?> означает «специализация List для конкретного типа, который нам неизвестен».

В rawArgs() компилятор знает, что Holder является обобщенным типом, поэтому даже несмотря на то, что здесь он
выражается неспециализированным типом, компилятор знает, что передача Object методу set() небезопасна.
Так как это неспециализированный тип, методу set() можно передать объект любого типа, и этот объект будет приведен к
Object восходящим преобразованием. Итак, каждый раз, когда вы используете неспециализированный тип, вы отказываетесь
от проверки на стадии компиляции. Вызов get() демонстрирует ту же проблему: при отсутствии т результатом может быть только Object.

Легко прийти к мнению, что неспециализированные типы `Holder` и Holder<?> обозначают приблизительно одно и то же.
Но метод unboundedArg() подчеркивает различия между ними — он выявляет те же проблемы, но сообщает о них как об
ошибках, а не как о предупреждениях, потому что неспециализированный тип Holder может содержать комбинацию любых типов,
а Holder<?>  содержит однородную коллекцию некоторого конкретного типа, а следовательно, передать Object просто не получится.
В `exact1()` и `exact2()` используются точные параметры обобщений — без масок. Как видно по дополнительному аргументу, exact2()
имеет другие ограничения, чем `exact1()`. В `wildSubtype()` ограничения для типа Holder ослабляются до Holder для любых
типов, расширяющих T. И снова это означает, что типом т может быть `Fruit`, тогда как holder может содержать `Holder<Apple>`.
Чтобы предотвратить помещение Orange в `Holder<Apple>`, вызов set () (или любого другого метода, получающего параметр-тип) запрещен.
Но при этом вы знаете, что все, что выходит из `Holder< ? extends Fruit>`, будет по меньшей мере `Fruit`, поэтому вызов `get()`
(или любого метода, возвращающего параметр-тип) разрешен.

Легко прийти к мнению, что неспециализированные типы Holder и Holder<?> обозначают приблизительно одно и то же. Но метод unboundedArg()
подчеркивает различия между ними — он выявляет те же проблемы, но сообщает о них как об ошибках, а не как о предупреждениях, потому что
неспециализированный тип Holder может содержать комбинацию любых типов, а Holder<?> содержит однородную коллекцию некоторого конкретного
типа, а следовательно, передать Object просто не получится.

В wildSubtype() ограничения для типа Holder ослабляются до Holder для любых типов, расширяющих T. И снова это означает,
что типом т может быть Fruit, тогда как holder может содержать Holder<Apple>. Чтобы предотвратить помещение Orange в Holder<Apple>,
вызов set () (или любого другого метода, получающего параметр-тип) запрещен. Но при этом вы знаете, что все, что выходит
из Holder< ? extends Fruit>, будет по меньшей мере Fruit, поэтому вызов get() (или любого метода, возвращающего параметр-тип) разрешен.

Применение маски супертипа продемонстрировано в методе `wildSupertype()`, поведение которого обратно поведению `wildSubtype()`:
`holder` может содержать контейнер с элементами любого типа, который является разновидностью базового класса т. Таким образом,
`setValue()` может принять `T`, так как все, что работает с базовым типом, будет полиморфно работать с производным типом (отсюда т).
Однако попытка вызова **getValue()** пользы не принесет, потому что тип, хранимый в **holder**, может быть абсолютно любым супертипом,
поэтому единственным безопасным вариантом является **Object**. Этот пример также показывает ограниченные возможности выполнения
операций с неограниченным параметром в **unbounded()**: вы не можете вызвать **getValue()** или **set()** для **T**, потому что у вас нет **T**.

В методе **main()** мы видим, какие из этих методов могут получать те или иные типы аргументов без ошибок и предупреждений.
Для обеспечения миграционной совместимости **rawArgs()** будет получать все разновидности **Holder** без выдачи предупреждений.
Метод **unboundedArg()** также принимает все типы, хотя, как упоминалось ранее, в теле метода он работает с ними иначе.

Если передать неспециализированную ссылку **Holder** методу, который получает «точный» обобщенный тип (без маски),
вы получите предупреждение, потому что точный аргумент ожидает получить информацию, не существующую в неспециализированном типе.
И если передать неограниченную ссылку **exact1()**, то у компилятора не будет информации о типе для установления возвращаемого типа.
Мы видим, что метод **exact2()** имеет больше всего ограничений, поскольку он должен получать **Holder<T>** и аргумент типа **T**;
не получив точных аргументов, он выдает ошибки и предупреждения. Иногда такой подход приемлем, но если он создает неудобства,
вы можете использовать маски в зависимости от того, хотите ли вы получать возвращаемые значения из своего обобщенного аргумента
(как в **wildSubtype()**) или передавать в нем типизованные аргументы (как в **wildSupertype()**).

Таким образом, преимущество использования точных типов вместо масок заключается в том, что оно позволяет больше сделать
с обобщенными параметрами.

С другой стороны, использование масок позволяет принять в аргументах более широкий диапазон параметризованных типов.
Вы должны решить, какой из вариантов лучше подходит для ваших потребностей, в каждом конкретном случае.

## Фиксация

Есть ситуация, в которой использование <?> вместо неспециализированного типа особенно принципиально.
Если передать неспециализированный тип методу, использующему<?>, компилятор может автоматически вычислить фактический
параметр-тип и вызвать другой метод, использующий точный тип. Следующий пример демонстрирует работу этого механизма,
который называется фиксацией (capture conversion), потому что неуказанный тип маски фиксируется и преобразуется к точному типу.
В этом случае комментарии о предупреждениях действуют только при удалении аннотации **@SuppressWarnings**:

Все параметры-типы f1() являются точными, не содержат масок или ограничений. В f2() параметр Holder является неограниченной маской,
так что на первый взгляд он фактически неизвестен. Однако в f2 () вызывается метод f1 (), которому требуется известный параметр.
Здесь параметр-тип фиксируется в процессе вызова f2() и может использоваться при вызове f1().

Нельзя ли использовать эту методику для записи? Для этого вместе с Holder<?> необходимо передавать конкретный тип.
Фиксация работает только в ситуациях, при которых внутри метода необходимо работать с точным типом. Учтите, что вы не можете вернуть
т из f2(), потому что тип т неизвестен для f2(). Фиксация — интересный механизм, но его возможности невелики.

## Проблемы

### Примитивы не могут использоваться как параметры-типы

Как упоминалось ранее в этой главе, один из недостатков o6o6ntemmJava заключается в том, что примитивы не могут использоваться 
в качестве параметров-типов. Таким образом, например, вы не сможете создать ArrayList<int>.

Проблема решается использованием примитивных классов-«оберток» в сочетании с автоматической ynaKOBKoftJava SE. 
Если вы создадите ArrayList<lnteger> и используете примитивные значения int с этим контейнером, вы обнаружите, 
что автоматическая упаковка выполняет преобразование к Integer и обратно автоматически — все выглядит так, словно 
вы работаете с ArrayList<int>:

Автоматическая упаковка даже позволяет использовать синтаксис foreach для производства int. В общем случае такое решение работает 
нормально — ваш код может успешно сохранять и читать int. При этом выполняются некоторые преобразования типа, но они остаются 
скрытыми от вас. Впрочем, если лишние преобразования создают проблемы с производительностью, вы можете использовать 
специализированную версию контейнеров, приспособленную для примитивных типов; одна из реализаций, с открытым кодом доступна 
по адресу org.apache.commons.collections.primitives.

Класс FArray содержит обобщенный метод, использующий генератор для заполнения массива объектами (переход к обобщенному классу 
в данном случае не работает, потому что метод является статическим). Реализации Generator взяты из главы 16, а в методе main() 
продемонстрировано использование FArray.fill() для заполнения массива объектами:

30. (2) Создайте объект Holder для каждой «обертки» примитивного типа.
    Продемонстрируйте, что автоматическая упаковка и распаковка работает для методов set () и get() каждого экземпляра

Так как RandomGenerator.lnteger реализует Generator<Integer>, я надеялся, что автоматическая упаковка преобразует значение next() 
из Integer в int. Однако автоматическая упаковка не применяется к массивам, поэтому решение не работает.

## Реализация параметризованных интерфейсов

Класс Hourly не компилируется, потому что стирание сокращает Payable<Employee> и Payable<Hourly> до одного класса 
Payable, а приведенный выше код будет означать, что один интерфейс реализуется дважды. Интересно, что при удалении 
обобщенных параметров из обоих мест использования РауаЫе (как это делает компилятор при стирании) код откомпилируется.
Эта проблема проявляется при работе с некоторыми фундаментальными интерфейсами Java (такими, как Comparable<T>), как будет 
показано позже в этом разделе.

## Приведения типа и предупреждения
Без аннотации @SuppressWarnings компилятор выдает для pop() предупреждение «неконтролируемое приведение типа». 
Из-за стирания он не знает, безопасно ли приведение типа, и метод pop() не выполняет никакого реального приведения, 
T стирается по первому ограничению, которым по умолчанию является Object, так что pop() фактически просто преобразует Object в Object.

## Самоограничиваемые типы

`public class CuriouslyRecurringGeneric extends GenericType<CuriouslyRecurringGeneric>{ }`
Происходящее можно назвать «необычным рекурсивным обобщением» (curiously recurring generics, CRG) по названию паттерна 
«Необычный рекурсивный шаблон» для С++, описанного Джимом Коплином. Под «необычной рекурсией» имеется в виду то, 
что класс несколько необычно появляется в своем базовом классе.

Чтобы понять, что это значит, попробуйте произнести вслух: «Я создаю новый класс, производный от обобщенного типа, 
который получает имя моего класса как параметр». Что может сделать обобщенный базовый тип при получении имени производного класса? 
Основной смысл o6o6iuemmBjava проявляется в передаче аргументов и возвращаемых типов, так что он может создать базовый класс, 
использующий производный тип в типах своих аргументов и возвращемого значения. Также производный тип может использоваться для типов 
полей, несмотря на то что они будут стерты до Object

```
public class BasicHolder<T> {
    T element;
    void set(T args) {
        element = args;
    }

    T get() {
        return element;
    }

    void f() {
        System.out.println(element.getClass().getSimpleName());
    }
}
```

Это вполне рядовой обобщенный тип с методами, которые получают и возвращают объекты параметра-типа, а также методом, 
который работает с полем (хотя и выполняет с ним только операции Object)

Обратите внимание на важную подробность: новый класс Subtype получает аргументы и возвращает значения типа Subtype, 
а не базового класса BasicHolder. В этом проявляется сущность «необычных рекурсивных обобщений: базовый класс заменяет свои 
параметры производным классом. Это означает, что обобщенный базовый класс становится своего рода шаблоном общей 
функциональности для всех производных классов, но эта функциональность будет использовать производный тип для всех своих 
аргументов и возвращаемых значений. Иначе говоря, в полученном классе будет использоваться точный тип вместо базового типа. 
Таким образом, в Subtype и аргументы set(), и возвращаемое значение get() относятся к точному типу Subtype.

## Самоограничение

`BasicHolder` может использовать в своем обобщенном параметре любой тип

```
public class Unconstrained {
    public static void main(String[] args) {
        BasicOther b = new BasicOther();
        BasicOther b2 = new BasicOther();

        b.set(new Other());

        Other other = b.get();

        System.out.print("b.getClassSimpleName = ");
        b.f();

        b2.set(other);

        System.out.println("b2.getClassSimpleName = " + b2.get().getClass().getSimpleName());
    }
}
```

Самоограничение делает следующий шаг: оно заставляет обобщение использовать самого себя в качестве аргумента ограничения.

```
public class SelfBounding {
    public static void main(String[] args) {
        A a = new A();
        a.set(new A());

        a = a.set(new A()).get();

        a = a.get();

        C c = new C();

        c = c.setAndGet(new C());
    }
}
```

Итак, самоограничение служит только для принудительного соблюдения отношений наследования. Используя самоограничение, вы знаете, 
что параметр-тип, используемый классом, будет относиться к тому же базовому типу, что и класс, использующий этот параметр. 
Оно заставляет всех пользователей этого класса следовать указанному образцу.

```
public class SelfBoundingMethods {
    static <T extends SelfBounded<T>> T f(T args) {
        return args.set(args).get();
    }

    public static void main(String[] args) {
        A a = f(new A());
    }
}
```

Тем самым вы запрещаете применять метод к чему-либо, кроме самоограниченного аргумента представленной формы.

## Ковариантность аргументов
Полезность самоограничиваемых аргументов заключается в том, что они производят ковариантные типы 
аргументов — типы аргументов методов меняются в соответствии с субклассами.
И хотя самоограничиваемые типы также производят возвращаемые типы, соответствующие типу субкласса, 
это не так важно, потому что ковариантные возвращаемые типы были представлены в Jave SE5

Метод get() в DerivedGetter переопределяет get() из OrdinaryGetter и возвращает тип, производный от типа, 
возвращаемого OrdinaryGetter. get (). И хотя это абсолютно логично — метод производного типа должен быть способен 
вернуть более конкретный тип, чем переопределяемый метод базового типа, — в предыдущих версиях Java это было недопустимо.
```
public class OrdinaryArguments {
    public static void main(String[] args) {
        Base base = new Base();
        Derived derived = new Derived();

        DerivedSetter derivedSetter = new DerivedSetter();
        derivedSetter.set(derived);

        derivedSetter.set(base);
    }
}
```

Оба вызова — set(derived) и set(base) — допустимы, так что DerivedSetter.set() не переопределяет OrdinarySetter.set(), а перегружает 
этот метод. Из выходных данных видно, что в DerivedSetter содержатся два метода, так что версия базового класса остается доступной; 
это подтверждает факт перегрузки.

```
public class PlainGenericInheritance {
    public static void main(String[] args) {
        Base base = new Base();
        Derived derived = new Derived();
        DerivedGS derivedGS = new DerivedGS();

        derivedGS.set(derived);
        derivedGS.set(base);
    }
}

DerivedGS.set(Derived)
GenericSetter.set( Base )
```
Этот код имитирует OrdinaryArguments.java; в этом примере DerivedSetter наследует от класса OrdinarySetter, содержащего метод set(Base).
Здесь класс DerivedGS наследует от GenericSetter<Base>, который также содержит метод 5еТ(Ва5е),созданный обобщением. Как и в случае 
OrdinaryArguments.java, из результатов видно, что DerivedGS содержит две перегруженные версии set(). Без самоограничения перегрузка 
осуществляется по типам аргументов. Если вы используете самоограничение, остается только одна версия метода, получающая точный 
тип аргумента.

## Динамическая безопасность типов
Так как обобщенные контейнеры могут передаваться коду, написанному floJava SE5, все еще остается опасность повреждения контейнеров 
старым кодом. BJava SE5 входит библиотека java.util.Collections с набором инструментов для решения проблем проверки типов в подобных 
ситуациях: статические методы checkedCollection(), checkedList(), checkedMap(), checkedSet(), checkedSortedMap() и checkedSortedSet(). 
Каждый метод в первом аргументе получает контейнер, который вы хотите динамически проверять, а во втором — тип, который требуется выдержать.

Контролируемый контейнер возбуждает исключение CiassCastException при попытке вставки неподходящего объекта (в отличие от 
неспециализированного контейнера, который сообщит о проблеме при извлечении объекта). В последнем случае вы знаете, что проблема 
существует, но не знаете ее причины; с контролируемыми контейнерами вы будете знать, кто попытался вставить недопустимый объект).

``` java
    public class CheckedList {
        @SuppressWarnings("unchecked")
        static void oldStyleMethod(List probablyDogs) {
            System.out.println(probablyDogs.getClass().getSimpleName());
            probablyDogs.add(new Cat());
        }
    
        public static void main(String[] args) {
            List<Dog> dogs = new ArrayList<>();
            oldStyleMethod(dogs);
    
            List<Dog> dogs1 = Collections.checkedList(new ArrayList<>(), Dog.class);
    
            try {
                oldStyleMethod(dogs1);
            } catch (Exception e) {
                System.out.println(e.fillInStackTrace());
            }
    
            List<Animal> animals = Collections.checkedList(new ArrayList<>(), Animal.class);
            try {
                oldStyleMethod(animals);
            } catch (Exception e) {
                System.out.println(e.fillInStackTrace());
            }
        }
    }
```

ЗаПустив программу, вы увидите, что вставка Cat проходит незамеченной для dogsl, а dogs2 немедленно возбуждает исключение при 
вставке неправильного типа. Также видно, что объекты производного типа могут помещаться в контейнер с проверкой базового типа.

## Исключения

Из-за стирания возможности использования обобщений с исключениями сильно ограниченны. Блок catch не может перехватывать исключение 
обобщенного типа, потому что тип исключения должен быть известен и во время компиляции, и во время выполнения. Кроме того, обобщенный
класс не может прямо или косвенно наследовать от Throwable (это препятствует определению обобщенных исключений, которые невозможно 
перехватить).

Однако параметры-типы могут использоваться в секции throws объявления метода. Это позволяет писать обобщенный код

Смотри example34

Интерфейс Processor выполняет process() и может возбудить исключение типа E. Результат process() сохраняется В List<T> resultCollector. 
ProcessRunner содержит метод processAll(), который выполняет каждый содержащийся в нем объект Process и возвращает resultCollector.

## Примеси

Похоже, со временем термин «примесъъ (mixin) обрел много разных значений, но основной смысл подразумевает смешение функциональности 
нескольких классов для получения итогового класса, представляющего все типы примесей. Часто это делается в последнюю минуту, что позволяет 
легко и быстро объединять классы.

Одна из полезных особенностей примесей заключается в том, что они единообразно применяют характеристики и поведение нескольких классов. 
Кроме того, если вы захотите что-то изменить в классе примеси, эти изменения распространяются по всем классам, к которым применяется 
примесь. По этой причине примеси в определенном смысле связаны с аспектно-ориентированным программированием (АОП), а аспекты часто 
рекомендуют для решения проблемы примесей.

## Примеси с использованием интерфейсов

Класс Mixin фактически использует делегирование, так что каждый примесный тип требует поля в Mixin, и вы должны написать все необходимые методы в Mixin для передачи вызовов соответствующим объектам. В этом примере используются тривиальные классы, но при более сложных примесях код быстро разрастается1

```java
//example35
public class Mixins {
    public static void main(String[] args) {
        Mixin mixin = new Mixin();
        Mixin mixin1 = new Mixin();

        mixin.set("test string 1");
        mixin1.set("test string 2");

        System.out.println(mixin.get() + " " + mixin.getStamp() + " " + mixin.getSerialNumbered());
        System.out.println(mixin1.get() + " " + mixin1.getStamp() + " " + mixin1.getSerialNumbered());
    }
}
```

## Использование паттерна «Декоратор»

Если посмотреть на способ использования, концепция примеси кажется тесно связанной с паттерном проектирования «Декоратор». 
Декораторы часто используются в ситуациях, когда для обеспечения всех возможных комбинаций простое субкласси- рование порождает 
столько классов, что становится непрактичным.
Паттерн «Декоратор» использует иерархию объектов для динамического и прозрачного добавления обязанностей в отдельные объекты. 
Он определяет, что все объекты, являющиеся «обертками» для вашего исходного объекта, обладают единым базовым интерфейсом. 
Имеется декорируемый объект, а вы наращиваете его функциональность посредством добавления «оберток». Это делает использование 
декораторов прозрачным — имеется общий набор сообщений, которые могут отправляться объекту независимо от того, был он декорирован или нет. 
Декорирующий класс может добавлять методы, но, как вы вскоре увидите, в этом его возможности ограниченны.

Декораторы реализуются с использованием композиции и формальных структур (иерархия декорируемый объект/декоратор), 
тогда как примеси основываются на наследовании. Таким образом, примеси, основанные на параметризованном типе, можно рассматривать 
как обобщенный механизм декораторов, не требующий структуры наследования паттерна «Декоратор».

```java
//example36
public class Decoration {
    public static void main(String[] args) {
        TimeStamped timeStamped = new TimeStamped(new BasicD());
        TimeStamped timeStamped1 = new TimeStamped(new SerialNumberedD(new BasicD()));

//         t2.getSerialNumber();
//         Недоступно

        SerialNumberedD s = new SerialNumberedD(new BasicD());
        SerialNumberedD s2 = new SerialNumberedD( new TimeStamped(new BasicD()));
//        ! s2.getStamp();
//         Недоступно

    }
}
```
***
# ПРИМЕРЫ 

<p>I really like using Markdown.</p>
Don't put tabs or spaces in front of your paragraphs.

I just love **bold text**.

I just love <strong>bold text</strong>.

Love**is**bold

Italicized text is the *cat's meow*.

A*cat*meow

This is really***very***important text.

> Dorothy followed her through many of the beautiful rooms in her castle.
>
> The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.
>

> Dorothy followed her through many of the beautiful rooms in her castle.
>
>> The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.

1. Open the file.
2. Find the following code block on line 21:

        <html>
          <head>
            <title>Test</title>
          </head>

3. Update the title to match the name of your website.

``Use `code` in your Markdown file.``

***

## Примеси и динамические заместители

Динамический заместитель позволяет создать механизм, который более точно моделирует примеси, чем паттерн «Декоратор» 
(за информацией о динамических замести- телях^уа обращайтесь к главе 14). С динамическим заместителем динамический тип полученного 
класса образуется объединением всех смешиваемых типов.

В направлении поддержки примесей Bjava ведется значительная работа, включающая создание как минимум одного расширения — языка JavaJam, 
предназначенного специально для поддержки примесей.

```java
public class DynamicProxyMixin {
    public static void main(String[] args) {
        Object mixIn = MixinProxy.newInstance(
            tuple(new BasicImp(), BasicImp.class),
            tuple(new TimeStampedImp(), TimeStamped.class),
            tuple(new SerialNumberedImp(), SerialNumbered.class)
        );
        Basic b = (Basic)mixIn;
        TimeStamped timeStamped = (TimeStamped) mixIn;
        SerialNumbered serialNumbered = (SerialNumbered) mixIn;

        b.set("HELLO!");
        System.out.println(b.get());
        System.out.println(timeStamped.getStamp());
        System.out.println(serialNumbered.getSerialNumbered());
    }
}
```
