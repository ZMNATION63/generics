# Маски

## Неограниченные маски 556

Неограниченная маска <?> означает «что угодно», так что может показаться, что использование неограниченной маски эквивалентно
использованию самого типа. Действительно, компилятор на первый взгляд соглашается с этим предположением

Во многих ситуациях компилятор действительно совершенно не интересует, используете ли вы сам тип или <?>.
В таких случаях <?> можно рассматривать как обычное украшение. Тем не менее маска все же полезна, потому что она
фактически говорит: «Этот код написан с учетом обобщений^уа, и здесь имеется в виду, что в обобщенном параметре
может передаваться любой тип».

Если обобщение состоит только из неограниченных масок, как **Мар<?, ?>**, компилятор, похоже, не отличает его от «обычного» типа Мар.
Кроме того, **UnboundedWildcardsl.java** показывает, что компилятор по-разному рассматривает List<?> и List<? extends Object>.
При этом компилятор не всегда обращает внимание на различия между, допустим, **List** и **List<?>**; создается впечатление, что это
одно и то же, а это может породить путаницу. В самом деле, поскольку обобщенный аргумент стирается до первого ограничения,
List<?> кажется эквивалентом List<object>, а List по сути тоже является List<Object> — впрочем, оба эти утверждения не совсем точны.
List в действительности означает «неспециализированный контейнер List, в котором могут храниться любые объекты Object»,
тогда как List<?> означает «специализация List для конкретного типа, который нам неизвестен».

В rawArgs() компилятор знает, что Holder является обобщенным типом, поэтому даже несмотря на то, что здесь он
выражается неспециализированным типом, компилятор знает, что передача Object методу set() небезопасна.
Так как это неспециализированный тип, методу set() можно передать объект любого типа, и этот объект будет приведен к
Object восходящим преобразованием. Итак, каждый раз, когда вы используете неспециализированный тип, вы отказываетесь
от проверки на стадии компиляции. Вызов get() демонстрирует ту же проблему: при отсутствии т результатом может быть только Object.

Легко прийти к мнению, что неспециализированные типы Holder и Holder<?> обозначают приблизительно одно и то же.
Но метод unboundedArg() подчеркивает различия между ними — он выявляет те же проблемы, но сообщает о них как об
ошибках, а не как о предупреждениях, потому что неспециализированный тип Holder может содержать комбинацию любых типов,
а Holder<?> содержит однородную коллекцию некоторого конкретного типа, а следовательно, передать Object просто не получится.
В exact1() и exact2() используются точные параметры обобщений — без масок. Как видно по дополнительному аргументу, exact2()
имеет другие ограничения, чем exact1(). В wildSubtype() ограничения для типа Holder ослабляются до Holder для любых
типов, расширяющих T. И снова это означает, что типом т может быть Fruit, тогда как holder может содержать Holder<Apple>.
Чтобы предотвратить помещение Orange в Holder<Apple>, вызов set () (или любого другого метода, получающего параметр-тип) запрещен.
Но при этом вы знаете, что все, что выходит из Holder< ? extends Fruit>, будет по меньшей мере Fruit, поэтому вызов get()
(или любого метода, возвращающего параметр-тип) разрешен.

Легко прийти к мнению, что неспециализированные типы Holder и Holder<?> обозначают приблизительно одно и то же. Но метод unboundedArg()
подчеркивает различия между ними — он выявляет те же проблемы, но сообщает о них как об ошибках, а не как о предупреждениях, потому что
неспециализированный тип Holder может содержать комбинацию любых типов, а Holder<?> содержит однородную коллекцию некоторого конкретного
типа, а следовательно, передать Object просто не получится.

В wildSubtype() ограничения для типа Holder ослабляются до Holder для любых типов, расширяющих T. И снова это означает,
что типом т может быть Fruit, тогда как holder может содержать Holder<Apple>. Чтобы предотвратить помещение Orange в Holder<Apple>,
вызов set () (или любого другого метода, получающего параметр-тип) запрещен. Но при этом вы знаете, что все, что выходит
из Holder< ? extends Fruit>, будет по меньшей мере Fruit, поэтому вызов get() (или любого метода, возвращающего параметр-тип) разрешен.

Применение маски супертипа продемонстрировано в методе **wildSupertype()**, поведение которого обратно поведению wildSubtype():
holder может содержать контейнер с элементами любого типа, который является разновидностью базового класса т. Таким образом,
**setValue ()** может принять **T**, так как все, что работает с базовым типом, будет полиморфно работать с производным типом (отсюда т).
Однако попытка вызова **getValue()** пользы не принесет, потому что тип, хранимый в **holder**, может быть абсолютно любым супертипом,
поэтому единственным безопасным вариантом является **Object**. Этот пример также показывает ограниченные возможности выполнения
операций с неограниченным параметром в **unbounded()**: вы не можете вызвать **getValue()** или **set()** для **T**, потому что у вас нет **T**.

В методе **main()** мы видим, какие из этих методов могут получать те или иные типы аргументов без ошибок и предупреждений.
Для обеспечения миграционной совместимости **rawArgs()** будет получать все разновидности **Holder** без выдачи предупреждений.
Метод **unboundedArg()** также принимает все типы, хотя, как упоминалось ранее, в теле метода он работает с ними иначе.

Если передать неспециализированную ссылку **Holder** методу, который получает «точный» обобщенный тип (без маски),
вы получите предупреждение, потому что точный аргумент ожидает получить информацию, не существующую в неспециализированном типе.
И если передать неограниченную ссылку **exact1()**, то у компилятора не будет информации о типе для установления возвращаемого типа.
Мы видим, что метод **exact2()** имеет больше всего ограничений, поскольку он должен получать **Holder<T>** и аргумент типа **T**;
не получив точных аргументов, он выдает ошибки и предупреждения. Иногда такой подход приемлем, но если он создает неудобства,
вы можете использовать маски в зависимости от того, хотите ли вы получать возвращаемые значения из своего обобщенного аргумента
(как в **wildSubtype()**) или передавать в нем типизованные аргументы (как в **wildSupertype()**).

Таким образом, преимущество использования точных типов вместо масок заключается в том, что оно позволяет больше сделать
с обобщенными параметрами.

С другой стороны, использование масок позволяет принять в аргументах более широкий диапазон параметризованных типов.
Вы должны решить, какой из вариантов лучше подходит для ваших потребностей, в каждом конкретном случае.

## Фиксация

Есть ситуация, в которой использование <?> вместо неспециализированного типа особенно принципиально.
Если передать неспециализированный тип методу, использующему<?>, компилятор может автоматически вычислить фактический
параметр-тип и вызвать другой метод, использующий точный тип. Следующий пример демонстрирует работу этого механизма,
который называется фиксацией (capture conversion), потому что неуказанный тип маски фиксируется и преобразуется к точному типу.
В этом случае комментарии о предупреждениях действуют только при удалении аннотации **@SuppressWarnings**:

Все параметры-типы f1() являются точными, не содержат масок или ограничений. В f2() параметр Holder является неограниченной маской,
так что на первый взгляд он фактически неизвестен. Однако в f2 () вызывается метод f1 (), которому требуется известный параметр.
Здесь параметр-тип фиксируется в процессе вызова f2() и может использоваться при вызове f1().

Нельзя ли использовать эту методику для записи? Для этого вместе с Holder<?> необходимо передавать конкретный тип.
Фиксация работает только в ситуациях, при которых внутри метода необходимо работать с точным типом. Учтите, что вы не можете вернуть
т из f2(), потому что тип т неизвестен для f2(). Фиксация — интересный механизм, но его возможности невелики.

## Проблемы

### Примитивы не могут использоваться как параметры-типы

Как упоминалось ранее в этой главе, один из недостатков o6o6ntemmJava заключается в том, что примитивы не могут использоваться 
в качестве параметров-типов. Таким образом, например, вы не сможете создать ArrayList<int>.

Проблема решается использованием примитивных классов-«оберток» в сочетании с автоматической ynaKOBKoftJava SE. 
Если вы создадите ArrayList<lnteger> и используете примитивные значения int с этим контейнером, вы обнаружите, 
что автоматическая упаковка выполняет преобразование к Integer и обратно автоматически — все выглядит так, словно 
вы работаете с ArrayList<int>:

Автоматическая упаковка даже позволяет использовать синтаксис foreach для производства int. В общем случае такое решение работает 
нормально — ваш код может успешно сохранять и читать int. При этом выполняются некоторые преобразования типа, но они остаются 
скрытыми от вас. Впрочем, если лишние преобразования создают проблемы с производительностью, вы можете использовать 
специализированную версию контейнеров, приспособленную для примитивных типов; одна из реализаций, с открытым кодом доступна 
по адресу org.apache.commons.collections.primitives.

Класс FArray содержит обобщенный метод, использующий генератор для заполнения массива объектами (переход к обобщенному классу 
в данном случае не работает, потому что метод является статическим). Реализации Generator взяты из главы 16, а в методе main() 
продемонстрировано использование FArray.fill() для заполнения массива объектами:

30. (2) Создайте объект Holder для каждой «обертки» примитивного типа.
    Продемонстрируйте, что автоматическая упаковка и распаковка работает для методов set () и get() каждого экземпляра

Так как RandomGenerator.lnteger реализует Generator<Integer>, я надеялся, что автоматическая упаковка преобразует значение next() 
из Integer в int. Однако автоматическая упаковка не применяется к массивам, поэтому решение не работает.

## Реализация параметризованных интерфейсов